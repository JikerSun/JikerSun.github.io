<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>一个伪ios黑客的选读文章 | JakieSun_厕所蹲个驴</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="如题这个项目是破解ios app(前提ipa包是从越狱渠道获取到的,如: pp手机助手)! 介于一个工程师的道德标准,一定不要随意的修改其他app的功能! 文章1移动App入侵与逆向破解技术－iOS篇链接在这里 发布于 1 年前 作者 Bugly_Tony  235371 次浏览  来自 技术 如果您有耐心看完这篇文章，您将懂得如何着手进行app的分析、追踪、注入等实用的破解技术，另外，通过“入侵">
<meta name="keywords" content="ios开发">
<meta property="og:type" content="article">
<meta property="og:title" content="一个伪ios黑客的选读文章">
<meta property="og:url" content="http://yoursite.com/2018/01/04/一个伪ios黑客的选读文章/index.html">
<meta property="og:site_name" content="JakieSun_厕所蹲个驴">
<meta property="og:description" content="如题这个项目是破解ios app(前提ipa包是从越狱渠道获取到的,如: pp手机助手)! 介于一个工程师的道德标准,一定不要随意的修改其他app的功能! 文章1移动App入侵与逆向破解技术－iOS篇链接在这里 发布于 1 年前 作者 Bugly_Tony  235371 次浏览  来自 技术 如果您有耐心看完这篇文章，您将懂得如何着手进行app的分析、追踪、注入等实用的破解技术，另外，通过“入侵">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/images/hook1.jpeg">
<meta property="og:image" content="http://yoursite.com/images/hook2.jpeg">
<meta property="og:image" content="http://yoursite.com/images/hook3.jpeg">
<meta property="og:image" content="http://yoursite.com/images/hook4.jpeg">
<meta property="og:image" content="http://yoursite.com/images/hook5.jpeg">
<meta property="og:image" content="http://yoursite.com/images/hook6.jpeg">
<meta property="og:image" content="http://yoursite.com/images/hook7.jpeg">
<meta property="og:image" content="http://yoursite.com/images/hook8.jpeg">
<meta property="og:image" content="http://yoursite.com/images/hook9.jpeg">
<meta property="og:image" content="http://yoursite.com/images/hook10.jpeg">
<meta property="og:image" content="http://yoursite.com/images/hook11.jpeg">
<meta property="og:image" content="http://yoursite.com/images/hook12.jpeg">
<meta property="og:image" content="http://yoursite.com/images/hook13.jpeg">
<meta property="og:image" content="http://yoursite.com/images/hook14.jpeg">
<meta property="og:image" content="http://yoursite.com/images/hook15.jpeg">
<meta property="og:image" content="http://yoursite.com/images/hook16.jpeg">
<meta property="og:updated_time" content="2018-01-08T06:52:55.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="一个伪ios黑客的选读文章">
<meta name="twitter:description" content="如题这个项目是破解ios app(前提ipa包是从越狱渠道获取到的,如: pp手机助手)! 介于一个工程师的道德标准,一定不要随意的修改其他app的功能! 文章1移动App入侵与逆向破解技术－iOS篇链接在这里 发布于 1 年前 作者 Bugly_Tony  235371 次浏览  来自 技术 如果您有耐心看完这篇文章，您将懂得如何着手进行app的分析、追踪、注入等实用的破解技术，另外，通过“入侵">
<meta name="twitter:image" content="http://yoursite.com/images/hook1.jpeg">
  
    <link rel="alternative" href="/atom.xml" title="JakieSun_厕所蹲个驴" type="application/atom+xml">
  
  
    <link rel="icon" href="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1509965970128&di=50ef90b75009ba6bfa72bc1551bbe214&imgtype=0&src=http%3A%2F%2Fimg.25pp.com%2Fuploadfile%2Fsoft%2Fimages%2F2015%2F0725%2F20150725103726182.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
  
  

  <script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>
  <script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>

  
</head></html>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1606289047897&amp;di=8209eb27af71ac53b08f98b283de8eb2&amp;imgtype=0&amp;src=http%3A%2F%2Fhbimg.b0.upaiyun.com%2F96983db98a01a3ba5dbccbff32d1131e62e3e4551bbde-vtmFkh_fw658" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">JakieSun</a></h1>
		</hgroup>

		
		<p class="header-subtitle">韶华不为少年留,恨悠悠,几时休</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Android开发/" style="font-size: 13.33px;">Android开发</a> <a href="/tags/hexo探索/" style="font-size: 10px;">hexo探索</a> <a href="/tags/iOS/" style="font-size: 10px;">iOS</a> <a href="/tags/ios开发/" style="font-size: 20px;">ios开发</a> <a href="/tags/python开发/" style="font-size: 10px;">python开发</a> <a href="/tags/主播相关/" style="font-size: 10px;">主播相关</a> <a href="/tags/命令行端探索/" style="font-size: 10px;">命令行端探索</a> <a href="/tags/技术探索/" style="font-size: 16.67px;">技术探索</a> <a href="/tags/自动化打包/" style="font-size: 10px;">自动化打包</a> <a href="/tags/音乐篇/" style="font-size: 10px;">音乐篇</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/smackgg/hexo-theme-smackdown">smackdown</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/JikerSun">github</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://www.jianshu.com/u/1aae85c9610a">简书</a>
			        
			        </div>
				</section>
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">JakieSun</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1606289047897&amp;di=8209eb27af71ac53b08f98b283de8eb2&amp;imgtype=0&amp;src=http%3A%2F%2Fhbimg.b0.upaiyun.com%2F96983db98a01a3ba5dbccbff32d1131e62e3e4551bbde-vtmFkh_fw658" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">JakieSun</h1>
			</hgroup>
			
			<p class="header-subtitle">韶华不为少年留,恨悠悠,几时休</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-一个伪ios黑客的选读文章" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/01/04/一个伪ios黑客的选读文章/" class="article-date">
  	<time datetime="2018-01-04T08:37:12.000Z" itemprop="datePublished">2018-01-04</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      一个伪ios黑客的选读文章
      
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ios开发/">ios开发</a></li></ul>
	</div>

        

        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="如题"><a href="#如题" class="headerlink" title="如题"></a>如题</h2><p>这个项目是破解ios app(前提ipa包是从越狱渠道获取到的,如: pp手机助手)!</p>
<p>介于一个工程师的道德标准,一定不要随意的修改其他app的功能!</p>
<h1 id="文章1"><a href="#文章1" class="headerlink" title="文章1"></a>文章1</h1><h2 id="移动App入侵与逆向破解技术－iOS篇"><a href="#移动App入侵与逆向破解技术－iOS篇" class="headerlink" title="移动App入侵与逆向破解技术－iOS篇"></a>移动App入侵与逆向破解技术－iOS篇</h2><p><a href="https://dev.qq.com/topic/577e0acc896e9ebb6865f321" target="_blank" rel="noopener">链接在这里</a></p>
<p>发布于 1 年前</p>
<p>作者 Bugly_Tony  235371 次浏览  来自 技术</p>
<p>如果您有耐心看完这篇文章，您将懂得如何着手进行app的分析、追踪、注入等实用的破解技术，另外，通过“入侵”，将帮助您理解如何规避常见的安全漏洞，文章大纲：</p>
<p>简单介绍ios二进制文件结构与入侵的原理<br>介绍入侵常用的工具和方法，包括pc端和手机端<br>讲解黑客技术中的静态分析和动态分析法<br>通过一个简单的实例，来介绍如何综合运用砸壳、寻找注入点、lldb远程调试、追踪、反汇编技术来进行黑客实战<br>讲解越狱破解补丁和不需越狱的破解补丁制作方法和差别<br>黑客的素养</p>
<p>敏锐的嗅觉<br>有时候通过一个函数名，一个类名，就能大致的判断出它的作用，这就是嗅觉；功力已臻化境时，甚至可以使用第六感判断出一些注入点</p>
<p>面对失败的勇气<br>破解有时候很耗时，和程序开发正好相反，它耗时不是耗在写代码上，而是耗在寻找注入点和逆向工程上，有可能你花了3天时间去找程序的破绽，但是最终的破解代码可能就2行，不到一分钟就搞定了；但是你也需要做好面对失败的准备，如果路选错了，有可能你这3天完全是在浪费脑细胞</p>
<p>洪荒之力<br>洪荒之力－即入侵过程中需要借助的各种工具，工欲善其事，必先利其器，工具都是前人智慧的结晶，能用工具解决的，绝不要手动去搞</p>
<h3 id="iOS黑客关键字"><a href="#iOS黑客关键字" class="headerlink" title="iOS黑客关键字"></a>iOS黑客关键字</h3><p>iOS的入侵离不开越狱开发，一切的破解、入侵都是建立在越狱的基础上的，如果没有拿到系统级权限，一切的想法都是空谈了，当然，市面上存在免越狱的破解补丁，但是它的开发过程，也是基于越狱环境的</p>
<p>tweak</p>
<p>在iOS的黑客界，要做破解或越狱开发，就必须了解tweak，它是各种破解补丁的统称，在google上，如果你想搜索一些越狱开发资料或者开源的破解补丁代码，它是最好的关键字。</p>
<p>iOS的tweak大致分为两种：</p>
<p>第一种是在cydia上发布的，需要越狱才能安装，大部分是deb格式的安装包，iOS在越狱后，会默认安装一个名叫mobilesubstrate的动态库，它的作用是提供一个系统级的入侵管道，所有的tweak都可以依赖它来进行开发，目前主流的开发工具有theos和iOSOpenDev，前者是采用makefile的一个编译框架，后者提供了一套xcode项目模版，可以直接使用xcode开发可调试，但是这个项目已经停止更新了，对高版本的xcode支持不好，大家酌情选择（本文中的例子全部采用theos）</p>
<p>第二种是直接打包成ipa安装包，并使用自己的开发证书或者企业证书签名，不需越狱也可以安装，可直接放到自己的网站上，可实现在线安装；对于没有越狱的手机，由于权限的限制，我们是没有办法写系统级的tweak的，例如springboard的补丁是没法运行的，这种tweak大多是针对某个app，把目标app进行修改注入处理，再重新签名和发布，有点类似于windows软件的xxx破解版、xxx免注册版</p>
<p>没有越狱的机器由于系统中没有mobilesubstrate这个库，我们有二个选择，第一个是直接把这个库打包进ipa当中，使用它的api实现注入，第二个是直接修改汇编代码；第一个适用于较为复杂的破解行为，而且越狱tweak代码可以复用，第二种适用于破解一些if…else…之类的条件语句</p>
<p>Mobilesubstrate</p>
<p>下面的图展示的就是oc届著名的method swizzling技术，他就是iOS的注入原理，类似于windows的钩子，所以我们注入也称为hook</p>
<p>Mobilesubstrate为了方便tweak开发，提供了三个重要的模块：</p>
<p>MobileHooker 就是用来做上面所说的这件事的，它定义一系列的宏和函数，底层调用objc－runtime和fishhook来替换系统或者目标应用的函数</p>
<p>MobileLoader 用来在目标程序启动时根据规则把指定目录的第三方的动态库加载进去，第三方的动态库也就是我们写的破解程序，他的原理下面会简单讲解一下</p>
<p>Safe mode 类似于windows的安全模式，比如我们写的一些系统级的hook代码发生crash时，mobilesubstrate会自动进入安全模式，安全模式下，会禁用所有的第三方动态库</p>
<p>app注入原理</p>
<p>上面讲到了mobileloader，他是怎么做到把第三方的lib注入进目标程序的呢？这个我们要从二进制文件的结构说起，从下面的图来看，Mach-O文件的数据主体可分为三大部分，分别是头部（Header）、加载命令（Load commands）、和最终的数据（Data）。mobileloader会在目标程序启动时，会根据指定的规则检查指定目录是否存在第三方库，如果有，则会通过修改二进制的loadCommands，来把自己注入进所有的app当中，然后加载第三方库。</p>
<p>为了让大家看的更清楚，下面我用machoview来打开一个真实的二进制文件给大家看看，可以看出，二进制当中所有引用到的动态库都放在Load commands段当中，所以，通过给这个段增加记录，就可以注入我们自己写的动态库了</p>
<p>那么问题来了，在这里插入我们自己的动态库有什么用？我们自己写的代码没有执行的入口，我们一样没发干坏事，嗯，恭喜你问到点子上了，我们还需要一个”main”函数来执行我们自己的代码，这个”main”函数在oc里面称为构造函数，只要在函数前声明 “attribute((constructor)) static” 即可，有了它我们就可以发挥想象力，进行偷天换日干点坏事了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;CaptainHook/CaptainHook.h&gt;</span><br><span class="line"></span><br><span class="line">CHDeclareClass(AnAppClass);</span><br><span class="line">CHMethod(1, void, AnAppClass, say, id, arg1)</span><br><span class="line">&#123;</span><br><span class="line">NSString* tmp=@&quot;Hello, iOS!&quot;;</span><br><span class="line">CHSuper(1, AnAppClass, say, tmp);</span><br><span class="line">&#125;</span><br><span class="line">__attribute__((constructor)) static void entry()</span><br><span class="line">&#123;</span><br><span class="line">NSLog(@&quot;Hello, Ice And Fire!&quot;);</span><br><span class="line">CHLoadLateClass(AnAppClass);</span><br><span class="line">CHClassHook(1, AnAppClass,say);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里为止，我们已经知道了怎么在目标程序注入自己的代码，那么我们怎么知道需要hook哪些方法？怎么找到关键点进行实际的破解呢？下面讲一下常见的app入侵分析方法</p>
<h3 id="iOS逆向分析方法"><a href="#iOS逆向分析方法" class="headerlink" title="iOS逆向分析方法"></a>iOS逆向分析方法</h3><p>逆向分析最常用的有三种方法：</p>
<p>网络分析<br>通过分析和篡改接口数据，可以有效的破解通过接口数据来控制客户端行为的app，常用的抓包工具有Tcpdump, WireShark, Charles等，windows平台有fidller</p>
<p>静态分析<br>通过砸壳、反汇编、classdump头文件等技术来分析app行为，通过这种方式可以有效的分析出app实用的一些第三方库，甚至分析出app的架构等内容，常用的工具有dumpdecrypted（砸壳）、hopper disassembler（反汇编）、class_dump（导头文件）</p>
<p>动态分析<br>有静就有动，万物都是相生相克的，动态分析指的是通过分析app的运行时数据，来定位注入点或者获取关键数据，常用的工具有cycript（运行时控制台）、 lldb+debugserver（远程断点调试）、logify（追踪）</p>
<p>demo:微信抢红包插件</p>
<p>上面讲了很多原理性的东西，相信大家已经看的不耐烦了，下面我们一起动点真格的，我们从头开始，一步一步的做一个微信的自动抢红包插件，当然，网上可能已经有相关的开源代码了，但是我这里要讲的是，这些代码是怎么得出来的，我么重点讲一讲分析过程</p>
<p>工欲善其事，必先利其器</p>
<p>一台越狱的手机，并装有以下软件</p>
<p>cycript<br>dumpdecrypted<br>debug server<br>openssh<br>一台苹果电脑，并装有以下软件</p>
<p>class_dump<br>Theos<br>Hopper Disassembler v3<br>xcode<br>insert_dylib<br>pp助手</p>
<p>###寻找注入点</p>
<p>砸壳</p>
<p>首先我们要做的就是把微信的壳砸掉，砸壳其实是为了把它的头文件classdump出来，因为从appstore下载的app二进制都是经过加密的，直接进行classdump操作是啥也看不出来的</p>
<p>用pp助手把dumpdecrypted.dylib文件copy到微信的documents目录<br>ssh到手机的终端，cd到documents目录中，执行下面的命令进行砸壳操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xxx$ cp /usr/lib/dumpdecrypted.dylib /path/to/app/document</span><br><span class="line">xxx$ DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib /path/to/WeChat</span><br></pre></td></tr></table></figure></p>
<p>最后砸壳完成后会在documents目录生成砸了壳后的二进制文件，用pp助手copy出来并class-dump他的头文件备用<br>执行完这几行命令后，会在微信的documents目录生成一个WeChat.decrypted文件，这就是砸壳后的二进制文件；当然了，这一步不是必须的，我们可以直接从91或者pp助手下载一个已经砸过壳的版本</p>
<h3 id="动态分析－cycript"><a href="#动态分析－cycript" class="headerlink" title="动态分析－cycript"></a>动态分析－cycript</h3><p>要想实现自动抢红包，我们必须找到收到红包消息的handler方法，怎么入手呢？我们先从界面出发，进入微信的消息首发窗口:</p>
<p>ssh进手机的终端，输入ps命令，查找到微信的进程id<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep WeChat</span><br></pre></td></tr></table></figure></p>
<p>祭起神器cycript，根据上一步找到的pid注入到微信的进程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cycript -p pidxxx</span><br></pre></td></tr></table></figure></p>
<p>在cycript的终端输入这一串方法，作用就是打印出当前界面的view层级，（cycript还有很多妙用，大家可以上官网看文档，这里不详细介绍）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIApp.keyWindow.recursiveDescription().toString()</span><br></pre></td></tr></table></figure></p>
<p>最终的输出如下，内容太多，大家肯定看不清楚，不过没关系，这个不是重点，这里只是展示一下打印的结果形式：</p>
<p>我们可以随机的选取一个节点不要太靠树叶，也不要太靠树根，例如我选的是标红的部分，把这个节点的内存地址copy出来，这个内存地址，就代表了这个节点的view对象，ios开发的老油条们都知道，通过view的nextResponder方法，可以找出它所属的视图控制器ViewController，所以我么在cycript的控制台中持续输入如下的命令：</p>
<p>看到没有，通过四个nextResponder方法调用，我么找到了当前聊天窗口的ViewController类名，他就是BaseMsgContentViewController，现在我们缩小了目标范围，下面我们还需要继续缩小范围，要找到具体的消息处理函数才行。</p>
<h3 id="动态分析－Logify"><a href="#动态分析－Logify" class="headerlink" title="动态分析－Logify"></a>动态分析－Logify</h3><p>要继续缩小范围，就得祭起神器Logify了，它是theos的一个模块，作用就是根据头文件自动生成tweak，生成的tweak会在头文件的所有方法中注入NSLog来打印方法的入参和出参，非常适合追踪方法的调用和数据传递</p>
<p>现在我们根据此前砸壳后class_dump出来的头文件，找到BaseMsgContentViewController在pc终端执行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logify.pl /path/to/BaseMsgContentViewController.h &gt; /out/to/Tweak.xm</span><br></pre></td></tr></table></figure></p>
<p>输出的tweak文件大概是这个样子的：</p>
<p>这里带百分号的关键字，例如 %hook、%log、%orig 都是mobilesubstrate的MobileHooker模块提供的宏，其实也就是把method swizzling相关的方法封装成了各种宏标记，使用起来更简单，大家想要更深入了解各种标记，可以google一下logos语言</p>
<h3 id="theos创建tweak"><a href="#theos创建tweak" class="headerlink" title="theos创建tweak"></a>theos创建tweak</h3><p>上面我们用logify生成了一个tweak代码，我们要把它安装到手机上，首先需要使用theos进行编译，安装了theos之后，在pc终端输入nic.pl：</p>
<p>首先选择项目模版当然是tweak啦，然后是项目名称、作者，后面两个选项要注意：</p>
<p>首先是bundle filter，这个需要填你需要注入的目标app的bundle id，MobileLoader模块会根据它来寻找你的tweak的注入目标<br>最后是list id applications to terminate upon installation，这里指定当tweak安装成功之后，需要kill的进程，我们要hook微信，这里就填微信的二进制文件名就可以了，为什么要kill？ 因为我么的插件是需要在app启动时加载进去的，如果不重启app，插件是不会生效的<br>最后一切都完成后，在当前目录会生成下列文件：</p>
<p>把上面logify生成的tweak文件覆盖到当前目录，并用文本编辑器打开makefile文件，在文件的开头增加你的ios设备的ip地址和ssh端口：</p>
<p>最后在pc终端进入项目目录，输入 make package install 命令：</p>
<p>期间会让你输入设备的ssh密码，越狱机器的默认ssh密码是alpine，make命令会生成deb安装包，放在debs目录，我们如果想对外发布自己的插件，可以把生成的安装包上传到cydia即可</p>
<p>安装成功后再次进入微信的聊天界面，并使用另外一个微信在群里发个普通消息，连接xcode打开越狱机器控制台，查看输出，会发现有类似下面的输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Jun  7 09:56:13 Administratorde-iPhone WeChat[85972] &lt;Notice&gt;: [1;36m[WxMsgPreview] [m[0;36mTweak.xm:308[m [0;30;46mDEBUG:[m -[&lt;BaseMsgContentViewController: 0x15e0c9a00&gt; addMessageNode:&#123;m_uiMesLocalID=2, m_ui64MesSvrID=0, m_nsFromUsr=ccg*675~9, m_nsToUsr=1037957572@chatroom, m_uiStatus=1, type=1, msgSource=&quot;(null)&quot;&#125;  layout:1 addMoreMsg:0]</span><br></pre></td></tr></table></figure></p>
<p>看出来了吧，消息处理函数是BaseMsgContentViewController的<strong>addMessageNode:layout:addMoreMsg:</strong>方法，大家可以看出，方法的参数内容也打印出来了</p>
<h3 id="动态分析－lldb"><a href="#动态分析－lldb" class="headerlink" title="动态分析－lldb"></a>动态分析－lldb</h3><p>到目前为止，我么已经把范围缩小到了具体的函数，看起来注入点已经找到了，但是请大家思考一下，如果我们在这个函数中注入抢红包逻辑，那我们的tweak会不会有什么致命的缺陷？</p>
<p>是的，因为BaseMsgContentViewController这个类是微信群聊天窗口对应的controller，我么必须进入到群的聊天界面，这个类才会创建，如果不进入聊天窗口，我们的插件就不生效了，而且，即使进入聊天窗口，也只是能自动枪当前群的红包而已，其他群就无能为力了，是不是有点low？</p>
<p>所以为了使我们的插件显得上流一些，我么还要继续追根溯源，寻找消息的源头，这里就用到了lldb远程调试，使用lldb打断点的方式，通过调用栈，我们可以就可以看到当消息来到时，方法的调用顺序，找到最先执行的消息处理函数。</p>
<p>要在刚刚追踪到的<strong>addMessageNode:layout:addMoreMsg:</strong>方法中打断点，首先我们得知道它在运行时的内存地址，那么内存地址怎么来呢？有这么一个公式：</p>
<p>内存地址＝进程内存基地址＋函数在二进制中的偏移量<br>首先偏移量我们可以通过反汇编工具hooper来查，在pc上用hooper打开微信的二进制文件（注意，打开时会让你选择armv7或者arm64，这需要根据你越狱手机的cpu类型来选，一定要和你的手机一致），hooper的界面非常简洁，左侧有个搜索框，可以输入函数名，直接找到函数在二进制中的位置</p>
<p>通过左侧的搜索框搜addMessageNode关键字，找到它的偏移量是0x00000001017d7c6c：</p>
<p>找到了偏移量，还需要进程的基地址，这个地址需要连lldb，所以下面讲一下如何连接lldb进行远程调试，先ssh进越狱手机的终端，在终端输入如下命令（注意，你的手机必须连xcode调试过才会有这个命令）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debugserver *:19999 -a WeChat</span><br></pre></td></tr></table></figure>
<p>然后在pc端新起一个终端窗口，输入如下命令来连接手机端进行调试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lldb  -&gt;  process connect connect://deviceIP:19999</span><br></pre></td></tr></table></figure>
<p>如果连接成功，会进入lldb的控制台，我们在lldb的控制台输入如下命令来获取微信进程的基地址：</p>
<p>image list -o -f<br>执行这个命令会打印很多行数据，像下面图中这样，我么要找到微信的二进制文件所在的行，记录它的内存地址0X00000000000E800：</p>
<p>到这里我们两个地址都找到了，再通过br命令打断点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">br s -a &apos;0X00000000000E800+0x00000001017d7c6c&apos;</span><br></pre></td></tr></table></figure></p>
<p>打好断点后继续向群里面发消息，我们会发现进程被断掉了，这时输入bt指令，就可以看到当前的调用栈，就像下图这样：</p>
<p>分析堆栈的时候，重点找出模块时WeChat的项，这些都是微信模块的方法调用，有了堆栈，我们需要根据堆栈的内存地址找出它的具体函数名，思路还是先根据上面讲到的公式来计算出栈地址在二进制中的偏移量，然后用hooper找到偏移量对应的函数名</p>
<p>函数在二进制中的偏移量＝内存地址 - 进程内存基地址<br>例如根据箭头所指的内存地址和刚刚得到的进程基地址，计算偏移量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0000000101ad02f4 – 0x00000000000e8000 = 1019E82F4</span><br></pre></td></tr></table></figure></p>
<p>然后在hooper中搜索这个地址，得到结果如下：</p>
<p>最终把所有的栈都进行还原，得出调用栈是这个样子的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-[CMessageMgr MainThreadNotifyToExt:]:</span><br><span class="line">–&gt;</span><br><span class="line">-[BaseMsgContentLogicController OnAddMsg:MsgWrap:]:</span><br><span class="line">——&gt;</span><br><span class="line">-[RoomContentLogicController DidAddMsg:]</span><br><span class="line">———-&gt;</span><br><span class="line">-[BaseMsgContentLogicController DidAddMsg:]</span><br><span class="line">—————-&gt;</span><br><span class="line">-[BaseMsgContentViewController addMessageNode:layout:addMoreMsg:]:</span><br></pre></td></tr></table></figure></p>
<p>CMessageMgr这个类浮出水面了，是时候发挥黑客的嗅觉了，根据方法名我们能判断出MainThreadNotifyToExt:这个方法仅仅是用来发送通知的，如果hook这个方法，我们是拿不到消息内容的</p>
<p>由于这里可能是一个异步调用，用断点的方式，可能已经打印不出来栈信息了，所以还得使用logify来继续追踪CMessageMgr这个类，讲过的内容我就不重复了，直接得到最终的消息处理函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(void)AsyncOnAddMsg:(id)message MsgWrap:(CMessageWrap* )msgWrap</span><br></pre></td></tr></table></figure></p>
<p>实现“抢”的动作</p>
<p>上一节我们已经找到了hook的关键点，那么该如何去实现抢的动作？同样我们需要结合动态分析和静态分析，首先得到红包消息体的数据特征，然后再分析处理消息的关键点</p>
<p>数据包分析</p>
<p>首先我们的代码需要分辨哪些才是红包消息，方法很简单，用logify追踪BaseMsgContentViewController，然后向微信群发一个红包，观察手机日志输出，我们可以看出消息的数据结构中有个type字段，值是49，这个type应该就是标记消息类型的，如果不确定，可以再发个图片或者文本之类的消息，这个值是不同的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Administratorde-iPhone WeChat[47410] &lt;Notice&gt;: [1;36m[WxMsgPreview] [m[0;36mTweak.xm:308[m [0;30;46mDEBUG:[m -[&lt;BaseMsgContentViewController: 0x15e0c9a00&gt; addMessageNode:&#123;m_uiMesLocalID=16, m_ui64MesSvrID=1452438635530425509, m_nsFromUsr=1037957572@chatroom, m_nsToUsr=ccg*675~9, m_uiStatus=4, type=49, msgSource=&quot;&lt;msgsource&gt;</span><br><span class="line">&lt;silence&gt;0&lt;/silence&gt;</span><br><span class="line">&lt;membercount&gt;3&lt;/membercount&gt;</span><br><span class="line">&lt;/msgsource&gt;</span><br><span class="line">&quot;&#125;  layout:1 addMoreMsg:0]</span><br></pre></td></tr></table></figure>
<p>现在我们能分辨消息类型了，重点来了，怎么实现抢这个事呢，可能聪明人已经猜到了，从ui入手，先找到微信本身的抢红包函数，我们自己来给它构造参数并调用他不就行了？</p>
<p>把红包点开后，用cycript打印出当前view的层次，就像下面这个，一眼就可以看到重点，WCRedEnvelopesReceiveHomeView就是开红包弹框的类名</p>
<p>知道类名后，用cycript追踪它，点击开红包，在日志中找到了下图中的内容，从名字来看，这是一个事件处理函数，我们现在要做的，就是把他还原成oc代码，真正实现抢红包功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Administratorde-iPhone WeChat[91173] &lt;Notice&gt;: [1;36m[WxMsgPreview] [m[0;36mTweak.xm:8[m [0;30;46mDEBUG:[m -[&lt;WCRedEnvelopesReceiveHomeView: 0x13cdda8c0&gt; OnOpenRedEnvelopes]</span><br><span class="line">静态分析法</span><br></pre></td></tr></table></figure>
<p>怎么把他还原成oc代码，真正实现抢红包功能呢？还得借助一点点汇编技能，只是一点点而已，因为现在的反汇编工具已经很强大了，我们不需要挨个去看寄存器了</p>
<p>在pc上用hooper打开微信的二进制文件，搜索OnOpenRedEnvelopes，查看汇编代码，注意在图片中最后一行调用了一个WCRedEnvelopesReceiveHomeViewOpenRedEnvelopes函数</p>
<p>继续搜索WCRedEnvelopesReceiveHomeViewOpenRedEnvelopes这个方法，找到它的汇编代码</p>
<p>首先他不知道从哪里获取了一个payinfoitem<br>然后又获取了payinfo的m_c2cNativeUrl属性<br>然后调用substringfromindex吧navtiveurl的前缀截断，并调用bizutil的一个方法把url参数转换成了一个字典</p>
<p>最终反解出的代码如下，是不是很简单？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSString *nativeUrl = [[msgWrap m_oWCPayInfoItem] m_c2cNativeUrl];</span><br><span class="line">nativeUrl = [nativeUrl substringFromIndex:[@&quot;wxpay://c2cbizmessagehandler/hongbao/receivehongbao?&quot; length]];</span><br><span class="line">NSDictionary *nativeUrlDict = [%c(WCBizUtil) dictionaryWithDecodedComponets:nativeUrl separator:@&quot;&amp;&quot;];</span><br></pre></td></tr></table></figure></p>
<p>继续往下看, 在这里前面三行创建了一个mutable dictionary：</p>
<p>紧接着下面三个框框处都是调用了setobject：forkey：向里面填东西，那填的东西是啥呢？<br>其实这里已经可以看的很清楚了，第一个key是msgtype，值是字符串1，第二个sendid，值是调用了一个objectforkey从另一个字典中取出来的，很显然，另一个字典就是上面从url解析得到的，后面的channelid也是同样的道理</p>
<p>最终得到的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSMutableDictionary *args = [[%c(NSMutableDictionary) alloc] init];</span><br><span class="line">[args setObject:nativeUrlDict[@&quot;msgtype&quot;] forKey:@&quot;msgType&quot;];</span><br><span class="line">[args setObject:nativeUrlDict[@&quot;sendid&quot;] forKey:@&quot;sendId&quot;];</span><br><span class="line">[args setObject:nativeUrlDict[@&quot;channelid&quot;] forKey:@&quot;channelId&quot;];</span><br></pre></td></tr></table></figure></p>
<p>继续往下看从箭头所指的几处，我们可以看见，它的代码是这样的，共分为四步</p>
<p>第一个箭头调用了mmservicecenter的defaultcenter方法来获取mmservicecenter实例<br>第二个箭头调用了CContactMgr的class方法<br>第三个箭头调用了第一步获取的mmservicecenter实例的getservice方法，而这个方法是把第二步得到的class作为参数<br>第四个箭头很明白了吧，第三步得到了CContactMgr实例，这里就是调用CContactMgr实例的getselfcontact方法获取自己的账户资料</p>
<p>最终还原的到的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CContactMgr *contactManager = [[%c(MMServiceCenter) defaultCenter] getService:[%c(CContactMgr) class]];</span><br><span class="line">CContact *selfContact = [contactManager getSelfContact];</span><br></pre></td></tr></table></figure></p>
<p>继续往下看，这里使用刚刚得到的selfcontact来获取displayname和headimgurl，并把它们设置到刚刚的字典里面了，key分别是nickname和headimg</p>
<p>最终的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[args setObject:[selfContact getContactDisplayName] forKey:@&quot;nickName&quot;];</span><br><span class="line">[args setObject:[selfContact m_nsHeadImgUrl] forKey:@&quot;headImg&quot;];</span><br></pre></td></tr></table></figure></p>
<p>接着看，接下来这两段就比较蛋疼了，完全是从内存地址里面取的值，我也不知道他从哪里来，怎么办呢？有没有不懂汇编就能搞定它的捷径呢，答案是有！</p>
<p>对于第一个，我可以通过它的key猜出来，还记得最开始的时候我们取过payinfo的一个nativeurl属性吧，我们姑且把他传进去<br>对于第二个，我们可以猜测sessionUserName大概是会话名称，也就是群名称的意思，从哪里取这个值呢？我们先把也设置成伪代码</p>
<p>最终的结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[args setObject:nativeUrl forKey:@&quot;nativeUrl&quot;];</span><br><span class="line">[args setObject:xxx forKey:@&quot;sessionUserName&quot;];</span><br></pre></td></tr></table></figure></p>
<p>继续往下看，接下来这一段还是用mmservicecenter来获取WCRedLogicMgr对象，然后调用WCRedLogicMgr的open方法来拆红包，可以想象open方法的参数就是上面我们辛苦组装的字典</p>
<p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[[%c(MMServiceCenter) defaultCenter] getService:[%c(WCRedEnvelopesLogicMgr) class]] OpenRedEnvelopesRequest:args];</span><br></pre></td></tr></table></figure></p>
<p>领红包逻辑</p>
<p>到这里，我们再总结一下我们上面分析的过程…</p>
<p>得到m_oWCPayInfoItem属性<br>解析m_oWCPayInfoItem的m_c2cNativeUrl属性<br>得到selfcontact<br>组装相关参数<br>调用OpenRedEnvelopesRequest:领取红包<br>最终的抢红包代码合并起来如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;WxMsgPreview.h&quot;</span><br><span class="line"></span><br><span class="line">%hook CMessageMgr</span><br><span class="line"></span><br><span class="line">-(void)AsyncOnAddMsg:(id)message MsgWrap:(CMessageWrap* )msgWrap &#123;</span><br><span class="line">%log;</span><br><span class="line">%orig;</span><br><span class="line">if(msgWrap.m_uiMessageType == 49)&#123;</span><br><span class="line">CContactMgr *contactManager = [[%c(MMServiceCenter) defaultCenter] getService:[%c(CContactMgr) class]];</span><br><span class="line">CContact *selfContact = [contactManager getSelfContact];</span><br><span class="line"></span><br><span class="line">if ([msgWrap.m_nsContent rangeOfString:@&quot;wxpay://c2cbizmessagehandler/hongbao/receivehongbao&quot;].location != NSNotFound) &#123; // 红包</span><br><span class="line"></span><br><span class="line">NSString *nativeUrl = [[msgWrap m_oWCPayInfoItem] m_c2cNativeUrl];</span><br><span class="line">nativeUrl = [nativeUrl substringFromIndex:[@&quot;wxpay://c2cbizmessagehandler/hongbao/receivehongbao?&quot; length]];</span><br><span class="line"></span><br><span class="line">NSDictionary *nativeUrlDict = [%c(WCBizUtil) dictionaryWithDecodedComponets:nativeUrl separator:@&quot;&amp;&quot;];</span><br><span class="line"></span><br><span class="line">NSMutableDictionary *args = [[%c(NSMutableDictionary) alloc] init];</span><br><span class="line">[args setObject:nativeUrlDict[@&quot;msgtype&quot;] forKey:@&quot;msgType&quot;];</span><br><span class="line">[args setObject:nativeUrlDict[@&quot;sendid&quot;] forKey:@&quot;sendId&quot;];</span><br><span class="line">[args setObject:nativeUrlDict[@&quot;channelid&quot;] forKey:@&quot;channelId&quot;];</span><br><span class="line">[args setObject:[selfContact getContactDisplayName] forKey:@&quot;nickName&quot;];</span><br><span class="line">[args setObject:[selfContact m_nsHeadImgUrl] forKey:@&quot;headImg&quot;];</span><br><span class="line">[args setObject:nativeUrl forKey:@&quot;nativeUrl&quot;];</span><br><span class="line">[args setObject:msgWrap.m_nsFromUsr forKey:@&quot;sessionUserName&quot;];</span><br><span class="line"></span><br><span class="line">[[[%c(MMServiceCenter) defaultCenter] getService:[%c(WCRedEnvelopesLogicMgr) class]] OpenRedEnvelopesRequest:args];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">%end</span><br></pre></td></tr></table></figure>
<p>刚才说了，有两个疑难点没有解决:</p>
<p>第一：我们不知道payinfo是哪里来的，<br>第二：sessionusername我们也不知道是哪里来的<br>这时候我们可以从我们注入点的参数入手，首先用logify打印出addmsg方法的参数信息，会发现，它的第二个参数刚好有一个payinfo的属性，这样第一个问题迎刃而解了</p>
<p>第二个我们已经猜测到它代表群名称，所以我们从修改几次群名称，然后再观察logify打印出的参数值的变化，就可以确认出从哪里取了</p>
<p>通过一番折腾，得出了抢红包的核心代码，再结合上面章节所讲的theos制作tweak包的方法，打包并安装到手机，发个红包试试，是不是秒抢？</p>
<p>免越狱插件</p>
<p>检查依赖项</p>
<p>如果设备没有越狱，是没有mobilesubstrate等环境的，而且一些系统目录是没有读写权限的，这时我么只能从目标app的二进制文件入手，通过手动修改load commands来加载自己的dylib，那么上面我们的插件又是使用theos基于mobilesubstrate编译的，有没有办法确定我们的dylib有没有依赖其他的库呢？</p>
<p>使用osx自带的otool工具即可，可以看出，我们的lib是依赖于substrate库的，其他的都是系统库，所以我们从越狱设备中把cydiasubstrate文件copy出来重命名为libsunstrate.dylib，和我们的dylib一起放入wechat.app目录中</p>
<p>最后使用install_name_tool命令修改动态库的路径把它指向app二进制文件的同级目录</p>
<p>制作安装包</p>
<p>解决了依赖问题，然后要把我们的库注入到二进制weixin的二进制文件，这一步使用开源的insert_dylib即可 （@executable_path是一个环境变量，指的是二进制文件所在的路径）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">insert_dylib命令格式：</span><br><span class="line">./insert_dylib 动态库路径 目标二进制文件</span><br><span class="line"></span><br><span class="line">//注入动态库</span><br><span class="line">./insert_dylib [@executable_path](/user/name/executable_path)/wxmsgpreview.dylib WeChat</span><br><span class="line">//打包成ipa</span><br><span class="line">xcrun -sdk iphoneos PackageApplication -v WeChat.app -o ~/WeChat.ipa</span><br></pre></td></tr></table></figure>
<p>最后使用用企业证书或者开发证书签名对ipa重新签名，就可以放到自己的渠道进行发布了！</p>
<p>结语</p>
<p>通过综合运用各种工具，进行静态和动态分析，我们通过实战破解了微信的抢红包逻辑，明白了入侵常用的工具，上面的抢红包代码还有很多改进之处，比如没有判断红包的发送者是不是自己、也没有判断红包里面的文字是不是抢错三倍，有兴趣的童鞋可以尝试优化一下！</p>
<h1 id="文章2"><a href="#文章2" class="headerlink" title="文章2"></a>文章2</h1><h2 id="在非越狱手机上进行App-Hook"><a href="#在非越狱手机上进行App-Hook" class="headerlink" title="在非越狱手机上进行App Hook"></a>在非越狱手机上进行App Hook</h2><p>原创 2016-02-22 蒸米 唐巧</p>
<p><a href="https://mp.weixin.qq.com/s/hS29eNGr2cLeUQSyWEOEew" target="_blank" rel="noopener">链接在这哈</a></p>
<h2 id="推荐序"><a href="#推荐序" class="headerlink" title="推荐序"></a>推荐序</h2><p>蒸米是谁？他是阿里的资深安全工程师，是最先对 XcodeGhost 进行样本安全分析的人（见：<a href="https://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&amp;mid=209981128&amp;idx=1&amp;sn=a76f33ae940431607f067a20d097fc12&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Xcode编译器里有鬼 – XcodeGhost 样本分析</a> ）。实际上，XcodeGhost 这个名字，也是最先出自于蒸米的文章中。</p>
<p>在 XcodeGhost 作者跳出来说已经关闭了远程控制服务器后，他也是最先一个用实验证实可以伪造服务器进行「截胡」攻击的人（见：<a href="https://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&amp;mid=210077705&amp;idx=1&amp;sn=0c53236e24752861bb5e732600b9b4a3&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">XcodeGhost截胡攻击和服务端的复现，以及UnityGhost预警</a> ）。</p>
<p>这次，他发现了一个绕过非越狱 iPhone 沙盒的漏洞，并公布了相关视频，视频见：<a href="https://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&amp;mid=450497602&amp;idx=2&amp;sn=ea28812d93ab26e4c049f472817cfedc&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">绕过非越狱手机沙盒漏洞被发现</a>。</p>
<p>而公开漏洞并不是为了炫耀，而是为了最终推动 iOS 的安全发展，所以蒸米打算写一系列文章，介绍这里面涉及的相关技术，这些文章会首发在乌云上。我得到了蒸米的授权，转载于此。</p>
<p>许多人发现漏洞，都想的是如何利用漏洞给自己带来利益。而蒸米的想法却是：先公开视频，然后再提交给乌云（当然乌云会报告给厂商），然后再一点点介绍技术细节。等最终完整的技术细节出来的时候，这个漏洞应该已经无法有什么实质性的危害了。</p>
<p>这，就是一个「白帽子」的职业操守和理想。</p>
<p>感谢蒸米的分享和授权，本文的所有打赏归蒸米所有，以下是文章正文。</p>
<p>0x00 序</p>
<p>冰指的是用户态，火指的是内核态。如何突破像冰箱一样的用户态沙盒最终到达并控制如火焰一般燃烧的内核就是《iOS 冰与火之歌》这一系列文章将要讲述的内容。</p>
<p>但在讲主线剧情前，我们今天先聊一聊分支剧情 - 在非越狱的 iOS 上进行 App Hook。利用这个技术，你可以在非越狱的 iOS 系统上实现各种 hook 功能（e.g., 微信自动抢红包，自动聊天机器人，游戏外挂等），但写这篇文章的目的并不是鼓励大家使用外挂，更不是鼓励大家去卖外挂，所以千万不要用这个技术去做一些违法的事情。</p>
<p>《iOS 冰与火之歌》系列的目录如下：</p>
<p>1.<a href="https://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&amp;mid=450758201&amp;idx=1&amp;sn=c6a5f253a422e68dbbb278caae602d60&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Objective-C Pwn and iOS arm64 ROP</a></p>
<p>2.在非越狱的 iOS 上进行 App Hook（番外篇）</p>
<p>3.█████████████</p>
<p>4.█████████████</p>
<p>5.█████████████</p>
<p>6.另外文中涉及代码可在我的 github 下载:<br><a href="https://github.com/zhengmin1989/iOS_ICE_AND_FIRE" target="_blank" rel="noopener">https://github.com/zhengmin1989/iOS_ICE_AND_FIRE</a></p>
<h2 id="0x01-Mach-O-LC-LOAD-DYLIB-Hook"><a href="#0x01-Mach-O-LC-LOAD-DYLIB-Hook" class="headerlink" title="0x01 Mach-O LC_LOAD_DYLIB Hook"></a>0x01 Mach-O LC_LOAD_DYLIB Hook</h2><p>要是看过我写的安卓动态调试七种武器之离别钩 – Hooking（上）<a href="http://drops.wooyun.org/tips/9300" target="_blank" rel="noopener">http://drops.wooyun.org/tips/9300</a> 和 安卓动态调试七种武器之离别钩 – Hooking（下）<a href="http://drops.wooyun.org/papers/10156" target="_blank" rel="noopener">http://drops.wooyun.org/papers/10156</a> 的同学应该知道在 android 进行 hook 的方法可以是五花八本的。</p>
<p>其实在 iOS 上进行 hook 的方式也有很多，但是大多数都需要越狱后才能实现（比如大家最常用的 Cydia Substrate），今天我就来介绍一种不需要越狱就能 hook iOS app 方法，也就是Mach-O LC_LOAD_DYLIB Hook。这种方法是通过修改 binary 本身来加载第三方 dylib 并实现 hook，具体思路是：</p>
<p>提取 ipa 中的二进制文件 -&gt; 修改二进制文件的 Load Commands 列表，加入要 hook 的 dylib –&gt; hook.dylib 在函数 constructor 函数中完成对特定函数的 hook-&gt; 对修改后的 ipa 进行签名，打包和安装。</p>
<p>首先我们先来看一下我们将要进行注入的目标 app，这个 app 非常简单，就是调用上一章讲过的 talker 这个类输出一句”Hello, iOS!”。</p>
<p><img src="/images/hook1.jpeg" alt="“图”"></p>
<p>在 Products 文件夹中我们能够看到 IceAndFire.app 这个文件，也就是编译完后的 app：</p>
<p><img src="/images/hook2.jpeg" alt="“图”"></p>
<p>IceAndFire.app 其实就是个文件夹，里面可以看到很多的资源文件（签名信息，图片等），但最重要的东西就是与文件夹同名的 IceAndFire 这个二进制文件了。我们可以用 xxd 命令来看一下里面的内容：</p>
<p><img src="/images/hook3.jpeg" alt="&quot;图&quot;"></p>
<p>这个二进制文件里保存了 IceAndFire 这个 app 的所有逻辑，但是直接看二进制编码太辛苦了，这里我推荐一个叫做 MachOView 的软件（可以在我的 github 里下载），通过这个软件就可以看到整个 MachO 文件的结构了：</p>
<p><img src="/images/hook4.jpeg" alt="&quot;图&quot;"></p>
<p>在 Load Commands 这个数据段里，我们可以看到 IceAndFire 这个二进制文件会在启动的时候自动加载 Foundation, libobjc.A.dylib 等动态库。如果我们对 MachO 这个文件的 Load Commands 结构体进行修改，是不是就可以让 IceAndFire 这个 app 在启动的时候加载我们自定义的用来 hook 的 dylib 呢？没错，这个想法是可行的。并且我们只要在 dylib 的构造函数里完成相应的 hook 逻辑，就可以在 app 启动的时候对指定函数进行 hook 操作了。</p>
<p>那么如何修改 MachO 的结构体呢？用 010 editor 等二进制编辑器的确是一种方法，但实在是麻烦了点。好消息是金正日小分队已经把自动注入 dylib 的工具帮我们写好了。这个叫 yololib 的工具可以帮我们直接进行 dylib 的注入：<a href="https://github.com/KJCracks/yololib。但作者只放出了源码没有放出" target="_blank" rel="noopener">https://github.com/KJCracks/yololib。但作者只放出了源码没有放出</a> binary，我帮大家编译了一份扔到了我的 github 上 (<a href="https://github.com/zhengmin1989/iOS_ICE_AND_FIRE)。" target="_blank" rel="noopener">https://github.com/zhengmin1989/iOS_ICE_AND_FIRE)。</a></p>
<p>编译好 yololib 后，我们只需要在 mac 上执行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!bash</span><br><span class="line">./yololib [binary] [dylib file]</span><br><span class="line">./yololib [被插入 dylib 的二进制文件] [要插入的 dylib]</span><br></pre></td></tr></table></figure>
<p>命令即可完成 dylib 的注入，如图所示：</p>
<p><img src="/images/hook5.jpeg" alt="&quot;图&quot;"></p>
<p>现在我们再用 MachOView 看一下 IceAndFire 这个二进制文件就会看到 hook1.dylib 已经被我们成功注入进去了：</p>
<p><img src="/images/hook6.jpeg" alt="&quot;图&quot;"></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@executable_path/hook1.dylib</span><br></pre></td></tr></table></figure>
<p> 的意思是二进制文件会在当前目录下对 hook1.dylib 进行加载，所以我们编译好的 hook1.dylib 要和二进制文件一起放到 IceAndFire.app 文件夹里，这样才能保证我们在运行 app 的时候 hook1.dylib 能够被正确的加载。</p>
<h2 id="0x02-CaptainHook-for-Dylib"><a href="#0x02-CaptainHook-for-Dylib" class="headerlink" title="0x02 CaptainHook for Dylib"></a>0x02 CaptainHook for Dylib</h2><p>修改好了 app 二进制文件的 Load Commands 结构体后，我们再来看看如何构造进行 hook 的第三方 dylib。因为 app 自己肯定不会主动调用第三方 dylib 中的函数，所以如果我们想要让第三方 dylib 进行 hook 操作就要把 hook 的逻辑写到构造函数里。实现构造函数很简单，只要在函数前声明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((constructor)) static</span><br></pre></td></tr></table></figure></p>
<p>即可，我们先写个”Hello, Ice and Fire!” 测试一下：</p>
<p><img src="/images/hook7.jpeg" alt="&quot;图&quot;"></p>
<p>编译好 dylib 文件后，我们将这个 dylib 文件与 app 一起签名、打包、安装。然后我们运行一下程序就可以看到我们注入的 dylib 库已经在程序启动的时候成功加载并执行了。</p>
<p><img src="/images/hook8.jpeg" alt="&quot;图&quot;"></p>
<p>下一步就是要实现对特定函数的 hook。在这里我推荐使用 CaptainHook 这个 framework。作者已经帮我们实现了 hook 所需要的各种宏，只要按照如下步骤就可以完成针对特定函数的 hook：</p>
<ol>
<li>使用 CHDeclareClass() 声明想要 hook 的 class</li>
<li>在构造函数中用 CHLoadClass() 或 CHLoadLateClass() 加载声明过的 class</li>
<li>使用 CHMethod() hook 相应的 method</li>
<li>在 CHMethod() 中可以使用 CHSuper() 来调用原函数</li>
<li>在构造函数中使用 CHClassHook() 来注册将要 hook 的 method</li>
</ol>
<p>比如我们想要 hook Talker 这个 class 里的 say method，让 app 在调用 say 的时候修改 method 的参数，让 say 的话都变成”Hello, Android!”，我们只需要这样编写 dylib 的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#!objc</span><br><span class="line">#import &lt;CaptainHook/CaptainHook.h&gt;</span><br><span class="line"></span><br><span class="line">CHDeclareClass(Talker);</span><br><span class="line"></span><br><span class="line">CHMethod(1, void, Talker, say, id, arg1)</span><br><span class="line">&#123;</span><br><span class="line">NSString* tmp=@&quot;Hello, Android!&quot;;</span><br><span class="line">CHSuper(1, Talker, say, tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__((constructor)) static void entry()</span><br><span class="line">&#123;</span><br><span class="line">NSLog(@&quot;Hello, Ice And Fire!&quot;);</span><br><span class="line">CHLoadLateClass(Talker);</span><br><span class="line">CHClassHook(1, Talker,say);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CHMethod() 这个宏的格式是：参数的个数，返回值的类型，类的名称，selector 的名称，selector 的类型，selector 对应的参数的变量名。</p>
<p>CHClassHook() 这个宏的格式是：参数的个数，返回值的类型，类的名称，selector 的名称。</p>
<p>编写完代码后，我们对源码进行编译，将生成的 dylib 文件与 app 一起签名、打包、安装。然后我们运行一下程序就可以看到我们注入的 dylib 库已经成功的 hook 了 say method 了，原本应该输出”Hello, iOS!”，已经被我们成功的变成了”Hello, Android!”：</p>
<p><img src="/images/hook9.jpeg" alt="&quot;图&quot;"></p>
<h2 id="0x03-签名、打包和安装"><a href="#0x03-签名、打包和安装" class="headerlink" title="0x03 签名、打包和安装"></a>0x03 签名、打包和安装</h2><p>我们知道越狱后的 iPhone 有一个很重要的特性就是可以关闭 app 的签名校验，关掉签名校验后，App Store 上的 app（无论是收费的还是免费的）就可以随意盗版并且免费安装了。但是在非越狱的 iPhone 上，系统要求 app 必须要有合法的签名，负责无法进行安装。其实除了 AppStore 上的 app 有合法的签名外，我们还可以使用开发者证书或者企业证书来让没有合法签名的 app 拥有合法的签名。</p>
<p>当我们拥有开发者帐号并且在机器上安装了证书的话，就可以在 Keychain Access 这个工具中看到我们的签名信息：</p>
<p><img src="/images/hook10.jpeg" alt="&quot;图&quot;"></p>
<p>我们接下来要干的事情就是使用这个开发者证书来对我们修改后的 IceAndFire .app 进行签名。步骤如下：</p>
<p>1.首先先保证 IceAndFire.app 文件夹下有正确的 embedded.mobileprovision 文件：</p>
<p>如果没有的话，可以去苹果的开发者中心（developer.apple.com）生成。如果是个人开发者要注意将 iOS 设备的 UDID 加到开发者的设备列表中再生成 embedded.mobileprovision 文件，如果是企业证书则没有设备数量的限制。</p>
<p>2.正确的编写签名时使用的 Entitlements.plist：</p>
<p>这里最需要注意的就是 application-identifier 要包含正确的 Team ID (可以在开发者中心查看) 和对应的 Bundle ID。</p>
<p><img src="/images/hook11.jpeg" alt="&quot;图&quot;"></p>
<p>3.使用 codesign 对 hook 的 dylib 进行签名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!bash</span><br><span class="line">codesign -f -s &quot;iPhone Developer: zhengmin1989@gmail.com (XXXXXXXXX)&quot; IceAndFire.app/hook1.dylib</span><br></pre></td></tr></table></figure>
<p>4.使用 codesign 对 app 进行签名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!bash</span><br><span class="line">codesign -f -s &quot;iPhone Developer: zhengmin1989@gmail.com (XXXXXXXXX)&quot; --entitlements Entitlements.plist IceAndFire.app</span><br></pre></td></tr></table></figure>
<p>5.使用 xcrun 将 IceAndFire.app 打包成 IceAndFire.ipa：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!bash</span><br><span class="line">xcrun -sdk iphoneos PackageApplication -v IceAndFire.app  -o ~/iOSPwn/hook/github/IceAndFire.ipa</span><br></pre></td></tr></table></figure>
<p>6.使用 itunes 或者 mobiledevice 进行安装。</p>
<p><img src="/images/hook12.jpeg" alt="&quot;图&quot;"></p>
<p>成功的话会显示”OK”。然后就可以在非越狱的手机上使用我修改后的 app 了。</p>
<h2 id="0x04-Class-dump-和-ida"><a href="#0x04-Class-dump-和-ida" class="headerlink" title="0x04 Class-dump 和 ida"></a>0x04 Class-dump 和 ida</h2><p>通过上面几节的介绍，我们已经将非越狱 app hook 的流程走过一遍了，但这时候有人会问：” 你 hook 的 app 是自己写的，你当然知道应该 hook 哪个函数了，我想 hook 的 app 都是 App Store 上的，并没有源码，我该怎么办？” 其实这个问题也不难解决。只要用好 class-dump 和 ida 即可。</p>
<p>Class-dump 是一款可以用来 dump 头文件工具：</p>
<p><img src="/images/hook13.jpeg" alt="&quot;图&quot;"></p>
<p>比如我们想要 dump XXX 的头文件，只需要执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!bash</span><br><span class="line">./class-dump -H -o header XXX</span><br></pre></td></tr></table></figure>
<p>经过 dump 后，所有的头文件都会保存在”header” 这个文件夹中：</p>
<p><img src="/images/hook14.jpeg" alt="&quot;图&quot;"></p>
<p>每个头文件中都包含了类和方法的声明：<br><img src="/images/hook15.jpeg" alt="&quot;图&quot;"></p>
<p>可以看到，利用 class-dump 能够很好的帮助我们了解 app 的内部结构。但是 class-dump 只能获取 app 的头文件，并不能知道每个方法具体的逻辑，这时候我们就需要用到 ida 了。</p>
<p>利用 ida 我们可以获取到一个方法具体的逻辑，不过这需要你对 arm 汇编有一定的了解：</p>
<p><img src="/images/hook16.jpeg" alt="&quot;图&quot;"></p>
<p>比如上图所示的函数就是调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@”%@\n”)</span><br></pre></td></tr></table></figure></p>
<p>来向控制台输出参数的内容。只有了解了某个函数具体是做什么的，我们能才知道如何 hook 这个函数。</p>
<h2 id="0x05-微信自动抢红包的原理"><a href="#0x05-微信自动抢红包的原理" class="headerlink" title="0x05 微信自动抢红包的原理"></a>0x05 微信自动抢红包的原理</h2><p>至于微信自动抢红包的插件无非就是 hook 了接收微信消息的函数，然后判断消息中有没有红包，有的话就直接调用打开红包的函数即可。但因为这篇文章的主要目的是介绍非越狱手机的 app hook，而不是鼓励大家使用外挂，所以具体实现的细节就不公布了，有兴趣的同学可以自己尝试写一个。虽然效果没有机械流那么酷炫，但的确省时省力啊。</p>
<h2 id="0x06-总结"><a href="#0x06-总结" class="headerlink" title="0x06 总结"></a>0x06 总结</h2><p>通过这篇文章我们可以看到，即使是在非越狱的 iOS 系统上依然可以玩出很多的花样，因此各大 it 厂商不要盲目的相信非越狱 iOS 系统的安全性。针对红包和支付等比较重要的逻辑一定要有混淆和加固，针对 app 本身一定要有完整性校验。不然好心的白帽子可能只是写个自动抢红包的外挂玩玩，但是黑客就可能利用这种技术开发各种外挂来牟取暴利或者让用户在无意当中安装上带有后门的 app，随后会发生什么就只有天知道了。</p>
<p>最后感谢我的同事黑雪和耀刺对这篇文章的帮助和指导。</p>
<p>PS: 文中涉及代码可在我的 github 下载:</p>
<p><a href="https://github.com/zhengmin1989/iOS_ICE_AND_FIRE" target="_blank" rel="noopener">https://github.com/zhengmin1989/iOS_ICE_AND_FIRE</a></p>
<p>全文完。</p>
<h1 id="使用Reveal调试你的iOS-程序"><a href="#使用Reveal调试你的iOS-程序" class="headerlink" title="使用Reveal调试你的iOS 程序"></a>使用Reveal调试你的iOS 程序</h1><p>懒得复制了 <a href="https://www.jianshu.com/p/55c91033040c" target="_blank" rel="noopener">链接在这</a></p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在这里感谢以上各位大佬的文章及理念支持!<br><a href="https://github.com/JikerSun/IOS-APP-HOOK1" target="_blank" rel="noopener">github链接在这</a>!</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/01/04/项目研究参考链接/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">&lt;</strong>
      <div class="article-nav-title">
        
          项目研究参考链接
        
      </div>
    </a>
  
  
</nav>

  
</article>


<div class="ds-share share" data-thread-key="一个伪ios黑客的选读文章" data-title="一个伪ios黑客的选读文章" data-url="http://yoursite.com/2018/01/04/一个伪ios黑客的选读文章/"  data-images="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1606289047897&amp;di=8209eb27af71ac53b08f98b283de8eb2&amp;imgtype=0&amp;src=http%3A%2F%2Fhbimg.b0.upaiyun.com%2F96983db98a01a3ba5dbccbff32d1131e62e3e4551bbde-vtmFkh_fw658" data-content="一个伪ios黑客的选读文章">
    <div class="ds-share-inline">
      <ul  class="ds-share-icons-16">
      	<li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
        <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
        <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
        <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
        <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>
      </ul>
      <div class="ds-share-icons-more">
      </div>
    </div>
 </div>
 





</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2020 JakieSun
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/smackgg/hexo-theme-smackdown" target="_blank">Smackdown</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="/js/main.js"></script>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
</body>
</html>